@model socconvertor.Models.Email.EmailDispatchJob
@{
    ViewData["Title"] = "Bulk Send Progress";
}
<div class="container mt-3" id="progressApp">
    <h2>Bulk Send Progress</h2>
    <p class="text-muted">Job <code>@Model.JobId</code> created @Model.CreatedUtc.ToLocalTime().</p>

    <div class="row g-3 mb-3">
        <div class="col-md-2"><div class="card shadow-sm"><div class="card-body text-center"><h6>Total</h6><h4 id="totalVal">@Model.Total</h4></div></div></div>
        <div class="col-md-2"><div class="card shadow-sm"><div class="card-body text-center"><h6>Sent</h6><h4 id="sentVal">@Model.SuccessCount</h4></div></div></div>
        <div class="col-md-2"><div class="card shadow-sm"><div class="card-body text-center"><h6>Failed</h6><h4 id="failVal">@Model.FailedCount</h4></div></div></div>
        <div class="col-md-2"><div class="card shadow-sm"><div class="card-body text-center"><h6>Deferred</h6><h4 id="defVal">@Model.DeferredCount</h4></div></div></div>
        <div class="col-md-2"><div class="card shadow-sm"><div class="card-body text-center"><h6>Pending</h6><h4 id="pendVal">@Model.PendingCount</h4></div></div></div>
        <div class="col-md-2"><div class="card shadow-sm"><div class="card-body text-center"><h6>Rate/min</h6><h4 id="rateVal">0</h4></div></div></div>
    </div>

    <div class="progress position-relative mb-3" style="height:30px;">
        <div id="barSent" class="progress-bar bg-success" role="progressbar" style="width:0%"></div>
        <div id="barFailed" class="progress-bar bg-danger" role="progressbar" style="width:0%"></div>
        <div id="barDeferred" class="progress-bar bg-warning text-dark" role="progressbar" style="width:0%"></div>
        <div id="barPending" class="progress-bar bg-secondary" role="progressbar" style="width:0%"></div>
        <span id="barLabel" class="position-absolute top-50 start-50 translate-middle fw-bold"></span>
    </div>

    <div class="card mb-4">
        <div class="card-header">Status</div>
        <div class="card-body">
            <p id="statusText">Status: @Model.Status</p>
            <p id="resumeText" class="text-muted"></p>
            <p id="etaText" class="text-muted"></p>
            <p id="remainingText" class="text-muted"></p>
            <p id="todayText" class="text-muted"></p>
            <p id="tomorrowText" class="text-muted"></p>
            <!-- diagnostics added -->
            <p id="failuresText" class="text-danger"></p>
            <p id="liveStatusText" class="text-primary"></p>
            <p id="lastErrorText" class="text-muted" style="white-space:pre-wrap;"></p>

            <div id="pauseAlert" class="alert alert-warning d-none" role="alert">
                <i class="bi bi-exclamation-triangle-fill"></i> <strong>Auto-paused:</strong> Job paused after consecutive send failures (likely SMTP host unreachable). Will auto-resume shortly.
            </div>
            <div class="d-flex gap-2 mt-2">
                @if (Model.Status == socconvertor.Models.Email.EmailDispatchJobStatus.Queued || Model.Status == socconvertor.Models.Email.EmailDispatchJobStatus.Running || Model.Status == socconvertor.Models.Email.EmailDispatchJobStatus.PartiallyDeferred)
                {
                    <form method="post" asp-action="CancelJob" asp-controller="BulkEmail" onsubmit="return confirm('Cancel this job?');" class="d-inline">
                        @Html.AntiForgeryToken()
                        <input type="hidden" name="jobId" value="@Model.JobId" />
                        <button type="submit" class="btn btn-sm btn-outline-danger"><i class="bi bi-x-circle"></i> Cancel Job</button>
                    </form>
                }
                @if (TempData["SuccessMessage"] != null)
                {
                    <span class="badge bg-success align-self-center">@TempData["SuccessMessage"]</span>
                }
            </div>
        </div>
    </div>

    <div class="card mb-4">
        <div class="card-header">
            <ul class="nav nav-tabs card-header-tabs" id="itemsTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="sent-tab" data-bs-toggle="tab" data-bs-target="#sent-pane" type="button" role="tab">Sent (<span id="sentCount">0</span>)</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="pending-tab" data-bs-toggle="tab" data-bs-target="#pending-pane" type="button" role="tab">Pending (<span id="pendingCount">0</span>)</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="failed-tab" data-bs-toggle="tab" data-bs-target="#failed-pane" type="button" role="tab">Failed (<span id="failedCount">0</span>)</button>
                </li>
            </ul>
        </div>
        <div class="card-body">
            <div class="tab-content" id="itemsTabContent">
                <div class="tab-pane fade show active" id="sent-pane" role="tabpanel">
                    <div id="sentItems"></div>
                </div>
                <div class="tab-pane fade" id="pending-pane" role="tabpanel">
                    <div id="pendingItems"></div>
                </div>
                <div class="tab-pane fade" id="failed-pane" role="tabpanel">
                    <div id="failedItems"></div>
                </div>
            </div>
        </div>
    </div>

    <a class="btn btn-secondary" href="@Url.Action("InitiateManual","BulkEmail")">Back to Sessions</a>
</div>

@section Scripts {
<script>
(function(){
    const jobId='@Model.JobId';
    const sentVal=el('sentVal'); const failVal=el('failVal'); const defVal=el('defVal'); const pendVal=el('pendVal'); const totalVal=el('totalVal');
    const rateVal=el('rateVal'); const statusText=el('statusText'); const resumeText=el('resumeText'); const etaText=el('etaText'); const remainingText=el('remainingText');
    const todayText=el('todayText'); const tomorrowText=el('tomorrowText'); const pauseAlert=el('pauseAlert');
    const failuresText=el('failuresText'); const lastErrorText=el('lastErrorText'); const liveStatusText=el('liveStatusText');
    const barSent=el('barSent'); const barFailed=el('barFailed'); const barDeferred=el('barDeferred'); const barPending=el('barPending'); const barLabel=el('barLabel');

    function el(id){return document.getElementById(id);}

    // Item list state
    let currentTab = 'Sent';
    const itemPages = { Sent: 1, Pending: 1, Failed: 1 };
    const pageSize = 50;

    async function fetchItems(status, page = 1) {
        try {
            const r = await fetch(`@Url.Action("JobItemsJson","BulkEmail")?jobId=${encodeURIComponent(jobId)}&status=${encodeURIComponent(status)}&page=${page}&pageSize=${pageSize}`);
            const j = await r.json();
            if (!j.ok) { console.error('Failed to load items:', j.error); return; }
            renderItemsTable(status, j.items, j.page, j.pageSize, j.total);
        } catch (e) {
            console.error('Error fetching items:', e);
        }
    }

    function renderItemsTable(status, items, page, pageSize, total) {
        const containerId = status.toLowerCase() + 'Items';
        const container = document.getElementById(containerId);
        if (!container) return;

        const totalPages = Math.ceil(total / pageSize);

        let html = '<div class="table-responsive"><table class="table table-sm table-hover align-middle"><thead><tr><th>Debtor Code</th><th>Email</th><th>Status</th><th>Attempts</th><th>Last Attempt</th><th>Error</th></tr></thead><tbody>';
        
        if (items.length === 0) {
            html += '<tr><td colspan="6" class="text-muted text-center">No items</td></tr>';
        } else {
            for (const item of items) {
                const lastAttempt = item.lastAttemptUtc ? new Date(item.lastAttemptUtc).toLocaleString() : '-';
                const error = item.error ? `<small class="text-danger">${escapeHtml(item.error.substring(0, 100))}</small>` : '-';
                const attempts = item.attemptCount > 0 ? item.attemptCount : '-';
                html += `<tr><td><strong>${escapeHtml(item.debtorCode)}</strong></td><td>${escapeHtml(item.email)}</td><td><span class="badge bg-${statusBadge(item.status)}">${item.status}</span></td><td>${attempts}</td><td><small>${lastAttempt}</small></td><td>${error}</td></tr>`;
            }
        }
        html += '</tbody></table></div>';

        // Add pager
        if (totalPages > 1) {
            html += '<nav><ul class="pagination pagination-sm justify-content-center">';
            if (page > 1) html += `<li class="page-item"><a class="page-link" href="#" data-page="${page - 1}">Previous</a></li>`;
            for (let p = Math.max(1, page - 2); p <= Math.min(totalPages, page + 2); p++) {
                html += `<li class="page-item ${p === page ? 'active' : ''}"><a class="page-link" href="#" data-page="${p}">${p}</a></li>`;
            }
            if (page < totalPages) html += `<li class="page-item"><a class="page-link" href="#" data-page="${page + 1}">Next</a></li>`;
            html += '</ul></nav>';
        }

        container.innerHTML = html;

        // Attach pager handlers
        container.querySelectorAll('.page-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const newPage = parseInt(e.target.getAttribute('data-page'), 10);
                itemPages[status] = newPage;
                fetchItems(status, newPage);
            });
        });
    }

    function escapeHtml(text) {
        const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    function statusBadge(status) {
        if (status === 'Sent') return 'success';
        if (status === 'Failed') return 'danger';
        if (status === 'Pending' || status === 'Deferred') return 'secondary';
        return 'info';
    }

    // Tab click handlers
    document.getElementById('sent-tab').addEventListener('click', () => { currentTab = 'Sent'; fetchItems('Sent', itemPages.Sent); });
    document.getElementById('pending-tab').addEventListener('click', () => { currentTab = 'Pending'; fetchItems('Pending', itemPages.Pending); });
    document.getElementById('failed-tab').addEventListener('click', () => { currentTab = 'Failed'; fetchItems('Failed', itemPages.Failed); });

    let lastFailedCount = 0;

    async function poll(){
        try{
            const r=await fetch('@Url.Action("ProgressJson","BulkEmail")?jobId='+jobId);
            const j=await r.json();
            if(!j.ok){ statusText.textContent='Error: '+j.error; return; }
            sentVal.textContent=j.sent; failVal.textContent=j.failed; defVal.textContent=j.deferred; pendVal.textContent=j.pending; totalVal.textContent=j.total;
            rateVal.textContent=j.ratePerMinute;
            statusText.textContent='Status: '+j.status;

            // Show auto-pause alert if status=PartiallyDeferred and resume is soon
            if (j.status === 'PartiallyDeferred' && j.nextResumeUtc) {
                const resumeTime = new Date(j.nextResumeUtc);
                const now = new Date();
                const minutesUntilResume = Math.max(0, Math.round((resumeTime - now) / 60000));
                
                // Show alert if resume is within 30 minutes (likely an auto-pause from consecutive failures)
                if (minutesUntilResume < 30) {
                    pauseAlert.classList.remove('d-none');
                    resumeText.textContent = `Auto-resume in ~${minutesUntilResume} minute(s) (UTC: ${j.nextResumeUtc})`;
                } else {
                    // Long defer (e.g., daily/hourly cap), hide alert and show normal resume text
                    pauseAlert.classList.add('d-none');
                    resumeText.textContent = j.nextResumeUtc ? 'Next Resume (UTC): '+ j.nextResumeUtc : '';
                }
            } else {
                pauseAlert.classList.add('d-none');
                resumeText.textContent = j.nextResumeUtc ? 'Next Resume (UTC): '+ j.nextResumeUtc : '';
            }

            // diagnostics - show retry status and error details if available
            // Diagnostics: show consecutive failures and last error directly on page
            if (typeof j.consecutiveFailures !== 'undefined' && j.consecutiveFailures > 0) {
                failuresText.textContent = `Consecutive failures: ${j.consecutiveFailures}`;
            } else {
                failuresText.textContent = '';
            }

            // Live status: show what's happening right now
            const maxAttemptsFromJson = j.maxAttempts || 3;
            if (j.currentWaiting) {
                liveStatusText.innerHTML = `<i class="bi bi-hourglass-split"></i> <strong>Waiting for rate limit...</strong> Next: ${escapeHtml(j.currentWaiting.debtorCode)} (${escapeHtml(j.currentWaiting.email)})`;
                liveStatusText.className = 'text-info';
            } else if (j.currentSending) {
                const attempt = j.currentSending.attemptCount;
                if (attempt === 1) {
                    liveStatusText.innerHTML = `<i class="spinner-border spinner-border-sm"></i> <strong>Sending...</strong> ${escapeHtml(j.currentSending.debtorCode)} (${escapeHtml(j.currentSending.email)})`;
                    liveStatusText.className = 'text-primary';
                } else {
                    liveStatusText.innerHTML = `<i class="spinner-border spinner-border-sm"></i> <strong>Retrying send...</strong> ${escapeHtml(j.currentSending.debtorCode)} (${escapeHtml(j.currentSending.email)}) — attempt ${attempt}/${maxAttemptsFromJson}`;
                    liveStatusText.className = 'text-warning';
                }
            } else if (j.recentActivity) {
                // Recent activity within configured window
                const ra = j.recentActivity;
                if (ra.status === 'Sent') {
                    liveStatusText.innerHTML = `<i class="bi bi-check-circle"></i> Just sent ${escapeHtml(ra.debtorCode)} (${escapeHtml(ra.email)})`;
                    liveStatusText.className = 'text-success';
                } else if (ra.status === 'Failed') {
                    liveStatusText.innerHTML = `<i class="bi bi-exclamation-circle"></i> Recent failure: ${escapeHtml(ra.debtorCode)} (${escapeHtml(ra.email)})`;
                    liveStatusText.className = 'text-danger';
                } else {
                    liveStatusText.innerHTML = `<i class="bi bi-info-circle"></i> Recent activity: ${escapeHtml(ra.debtorCode)} (${escapeHtml(ra.email)})`;
                    liveStatusText.className = 'text-secondary';
                }
            } else if (j.status === 'Running' && j.remaining > 0) {
                liveStatusText.innerHTML = '<i class="bi bi-arrow-repeat"></i> Processing...';
                liveStatusText.className = 'text-secondary';
            } else {
                liveStatusText.textContent = '';
            }

            // Show last error separately (below live status)
            if (j.lastError) {
                const err = escapeHtml(j.lastError);
                const time = j.lastErrorTime ? ` (${new Date(j.lastErrorTime).toLocaleString()})` : '';
                lastErrorText.innerHTML = `<strong>Last error:</strong> ${err}${time}`;
            } else if (j.failureReason) {
                lastErrorText.textContent = j.failureReason;
            } else {
                lastErrorText.textContent = '';
            }

            lastFailedCount = j.failed;

            if(j.etaMinutes){ etaText.textContent='Estimated completion in ~'+ j.etaMinutes +' minute(s).'; } else etaText.textContent='';
            remainingText.textContent='Remaining: '+ j.remaining;

            // Update tab counts
            document.getElementById('sentCount').textContent = j.sent;
            document.getElementById('pendingCount').textContent = j.pending;
            document.getElementById('failedCount').textContent = j.failed;

            // Daily cap visibility
            if (typeof j.maxPerDay !== 'undefined') {
                const maxPerDay = j.maxPerDay;
                const sentToday = j.sentToday;
                const willSendToday = j.willSendToday;
                const willSendTomorrow = j.willSendTomorrow;
                todayText.textContent = `Today: sent ${sentToday} / ${maxPerDay > 0 ? maxPerDay : 'unlimited'} (will send ${willSendToday} more now)`;
                tomorrowText.textContent = willSendTomorrow > 0 ? `Deferred to next run: ${willSendTomorrow} recipient(s)` : '';
            }

            const total = j.total || 1;
            const pctSent = (j.sent/total)*100;
            const pctFailed = (j.failed/total)*100;
            const pctDeferred = (j.deferred/total)*100;
            const pctPending = (j.pending/total)*100;
            barSent.style.width=pctSent+'%';
            barFailed.style.width=pctFailed+'%';
            barDeferred.style.width=pctDeferred+'%';
            barPending.style.width=pctPending+'%';
            barLabel.textContent=Math.round((j.sent + j.failed + j.deferred)/total*100)+'%';
            if(['Completed','Failed','Cancelled'].includes(j.status)) return;
            setTimeout(poll,4000);
        }catch(e){ statusText.textContent='Polling error: '+e.message; setTimeout(poll,6000); }
    }

    // Initial load
    fetchItems('Sent', 1);
    poll();
})();
</script>
}
